---
title: "VibePong Game Data Analysis"
author: "Antigravity AI"
date: last-modified
format:
  html:
    theme: cosmo
    toc: true
    code-fold: true
    code-tools: true
    code-summary: "Show Code"
    code-copy: false
    
execute:
  echo: true
  warning: false
---

# Introduction

In this document, we analyze the game data generated by VibePong. The analysis covers data ingestion, cleaning, and exploratory data analysis (EDA) with visualizations.

# Step 1: Read Data

First, we search for all summary and action CSV files in the `game_data` directory and load them into pandas DataFrames.

```{python}
import pandas as pd
import glob
import os

# Define the data path
data_dir = './game_data'

# Get lists of files
summary_files = glob.glob(os.path.join(data_dir, 'vibepong_summary_*.csv'))
action_files = glob.glob(os.path.join(data_dir, 'vibepong_actions_*.csv'))

print(f"Found {len(summary_files)} summary files and {len(action_files)} action files.")

# Load and combine summary data
df_summary = pd.concat([pd.read_csv(f) for f in summary_files], ignore_index=True)

# Load and combine action data
df_actions = pd.concat([pd.read_csv(f) for f in action_files], ignore_index=True)
```


## Play by Play data
```{python}
# Display the first few rows of summary data
df_actions.head()
```


## Game by Game data
```{python}
# Display the first few rows of summary data
df_summary.head()
```

# Step 2: Data Cleaning

We will clean the data by converting timestamps to datetime objects, handling numeric types, and ensuring consistency.

```{python}
# 1. Convert Date in summary to datetime
df_summary['Date'] = pd.to_datetime(df_summary['Date'])

# 2. Ensure numeric types for metrics
numeric_cols = ['Duration (s)', 'Ball Speed', 'Lives', 'Hits']
for col in numeric_cols:
    df_summary[col] = pd.to_numeric(df_summary[col], errors='coerce')

# 3. Handle Action data timestamps
# Action timestamps are in ms (offset from game start)
df_actions['Timestamp (ms)'] = pd.to_numeric(df_actions['Timestamp (ms)'], errors='coerce')

# 4. Check for missing values
missing_counts = df_summary.isnull().sum()
print("Missing values in Summary data:")
print(missing_counts)

# Drop redundant rows if any (e.g. empty players if they didn't join)
df_summary = df_summary.dropna(subset=['Player'])

# Final head view after cleaning
df_summary.head()
```

# Step 3: EDA and Visualization

Now we'll look at some key performance indicators and visualize the game results.

## Win Distribution

Who is winning the most games?

```{python}
import seaborn as sns
import matplotlib.pyplot as plt

# Set aesthetic style
sns.set_theme(style="whitegrid")

# Count unique games per winner
unique_games = df_summary.drop_duplicates(subset=['Game ID'])
winner_counts = unique_games['Winner'].value_counts()

plt.figure(figsize=(10, 6))
sns.barplot(x=winner_counts.index, y=winner_counts.values, palette="viridis")
plt.title('Number of Wins by Player/CPU', fontsize=15)
plt.ylabel('Games Won')
plt.xlabel('Winner')
plt.show()
```

## Game Duration vs. Ball Speed

Does a higher ball speed lead to shorter games?

```{python}
plt.figure(figsize=(10, 6))
sns.scatterplot(data=unique_games, x='Ball Speed', y='Duration (s)', hue='Winner', s=100)
plt.title('Game Duration vs Ball Speed', fontsize=15)
plt.show()
```

## Total Hits per Player

Tracking the skill (hits) across different game sessions.

```{python}
plt.figure(figsize=(12, 6))
sns.boxplot(data=df_summary, x='Player', y='Hits', palette="magma")
plt.title('Distribution of Hits per Player', fontsize=15)
plt.show()
```

## Sequence of Actions

Analyzing the frequency of actions across all games.

```{python}
action_counts = df_actions['Action'].value_counts().head(10)

plt.figure(figsize=(12, 8))
action_counts.plot(kind='barh', color='skyblue')
plt.title('Most Frequent Actions/Events', fontsize=15)
plt.gca().invert_yaxis()
plt.show()
```
